{
  "quickstarts_go_eos_section1": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\tpb \"github.com/dfuse-io/docs/quickstarts/pb\"\n\t\"github.com/tidwall/gjson\"\n\t\"golang.org/x/oauth2\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/oauth\"\n)",
  "quickstarts_go_eos_section2": "func getToken(apiKey string) (token string, expiration time.Time, err error) {\n\treqBody := bytes.NewBuffer([]byte(fmt.Sprintf(`{\"api_key\":\"%s\"}`, apiKey)))\n\tresp, err := http.Post(\"https://auth.dfuse.io/v1/auth/issue\", \"application/json\", reqBody)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to obtain token: %s\", err)\n\t\treturn\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\terr = fmt.Errorf(\"unable to obtain token, status not 200, got %d: %s\", resp.StatusCode, reqBody.String())\n\t\treturn\n\t}\n\n\tif body, err := ioutil.ReadAll(resp.Body); err == nil {\n\t\ttoken = gjson.GetBytes(body, \"token\").String()\n\t\texpiration = time.Unix(gjson.GetBytes(body, \"expires_at\").Int(), 0)\n\t}\n\treturn\n}",
  "quickstarts_go_eos_section3": "func createClient(endpoint string) pb.GraphQLClient {\n\tdfuseAPIKey := os.Getenv(\"DFUSE_API_KEY\")\n\tif dfuseAPIKey == \"\" {\n\t\tpanic(\"you must specify a DFUSE_API_KEY environment variable\")\n\t}\n\n\ttoken, _, err := getToken(dfuseAPIKey)\n\tpanicIfError(err)\n\n\tcredential := oauth.NewOauthAccess(&oauth2.Token{AccessToken: token, TokenType: \"Bearer\"})\n\ttransportCreds := credentials.NewClientTLSFromCert(nil, \"\")\n\tconn, err := grpc.Dial(endpoint,\n\t\tgrpc.WithPerRPCCredentials(credential),\n\t\tgrpc.WithTransportCredentials(transportCreds),\n\t)\n\tpanicIfError(err)\n\n\treturn pb.NewGraphQLClient(conn)\n}",
  "quickstarts_go_eos_section4": "const operationEOS = `subscription {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\") {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`\n\ntype eosioDocument struct {\n\tSearchTransactionsForward struct {\n\t\tCursor string\n\t\tUndo   bool\n\t\tTrace  struct {\n\t\t\tID              string\n\t\t\tMatchingActions []struct {\n\t\t\t\tJSON map[string]interface{}\n\t\t\t}\n\t\t}\n\t}\n}",
  "quickstarts_go_eos_section5": "func streamEOSIO(ctx context.Context) {\n\t/* The client can be re-used for all requests, cache it at the appropriate level */\n\tclient := createClient(\"mainnet.eos.dfuse.io:443\")\n\texecutor, err := client.Execute(ctx, &pb.Request{Query: operationEOS})\n\tpanicIfError(err)\n\n\tfor {\n\t\tresp, err := executor.Recv()\n\t\tpanicIfError(err)\n\n\t\tif len(resp.Errors) > 0 {\n\t\t\tfor _, err := range resp.Errors {\n\t\t\t\tfmt.Printf(\"Request failed: %s\\n\", err)\n\t\t\t}\n\n\t\t\t/* We continue here, but you could take another decision here, like exiting the process */\n\t\t\tcontinue\n\t\t}\n\n\t\tdocument := &eosioDocument{}\n\t\terr = json.Unmarshal([]byte(resp.Data), document)\n\t\tpanicIfError(err)\n\n\t\tresult := document.SearchTransactionsForward\n\t\treverted := \"\"\n\t\tif result.Undo {\n\t\t\treverted = \" REVERTED\"\n\t\t}\n\n\t\tfor _, action := range result.Trace.MatchingActions {\n\t\t\tdata := action.JSON\n\t\t\tfmt.Printf(\"Transfer %s -> %s [%s]%s\\n\", data[\"from\"], data[\"to\"], data[\"quantity\"], reverted)\n\t\t}\n\t}\n}",
  "quickstarts_go_eos_section6": "func main() {\n\tproto := \"\"\n\tif len(os.Args) >= 2 {\n\t\tproto = os.Args[1]\n\t}\n\n\tswitch proto {\n\tcase \"ethereum\", \"ETH\":\n\t\tstreamEthereum(context.Background())\n\tdefault:\n\t\tstreamEOSIO(context.Background())\n\t}\n}\n\nfunc panicIfError(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}",
  "quickstarts_javascript_browser_ethereum_section1": "<head>\n    <style> li { font-family: monospace; margin: 0.15; }</style>\n    <script src=\"https://unpkg.com/@dfuse/client\"></script>\n    <script>\n        const client = dfuseClient.createDfuseClient({\n          // Replace 'web_abcdef12345678900000000000' with your own API key!\n          apiKey: 'web_abcdef12345678900000000000',\n          network: 'mainnet.eth.dfuse.io'\n        })\n    </script>\n</head>",
  "quickstarts_javascript_browser_ethereum_section2": "<script>\n// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1, cursor: $cursor) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`\n</script>",
  "quickstarts_javascript_browser_ethereum_section3": "<script>\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, node: { hash, value, matchingCalls }} = message.data.searchTransactions\n      matchingCalls.forEach(({ from, to, value }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${value} Ether]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}\n</script>",
  "quickstarts_javascript_browser_ethereum_section4": "<script>\nmain().catch((error) => document.body.innerHTML = `<p>${error}</p>`)\n</script>",
  "quickstarts_go_ethereum_section1": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\tpb \"go/graphql\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/tidwall/gjson\"\n\t\"golang.org/x/oauth2\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/oauth\"\n)\n\nfunc main() {\n\n\tdfuseAPIKey := os.Getenv(\"DFUSE_API_KEY\")\n\tif dfuseAPIKey == \"\" || dfuseAPIKey == \"your dfuse api key here\" {\n\t\tpanic(\"you must specify a DFUSE_API_KEY environment variable\")\n\t}\n\n\ttoken, _, err := getToken(dfuseAPIKey)\n\tpanicIfError(err)\n\n\tclient := createClient(\"mainnet.eth.dfuse.io:443\", token)\n\n\tstreamEthereum(context.Background(), client)\n}\n\nfunc panicIfError(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}",
  "quickstarts_go_ethereum_section2": "func getToken(apiKey string) (token string, expiration time.Time, err error) {\n\treqBody := bytes.NewBuffer([]byte(fmt.Sprintf(`{\"api_key\":\"%s\"}`, apiKey)))\n\tresp, err := http.Post(\"https://auth.dfuse.io/v1/auth/issue\", \"application/json\", reqBody)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to obtain token: %s\", err)\n\t\treturn\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\terr = fmt.Errorf(\"unable to obtain token, status not 200, got %d: %s\", resp.StatusCode, reqBody.String())\n\t\treturn\n\t}\n\n\tif body, err := ioutil.ReadAll(resp.Body); err == nil {\n\t\ttoken = gjson.GetBytes(body, \"token\").String()\n\t\texpiration = time.Unix(gjson.GetBytes(body, \"expires_at\").Int(), 0)\n\t}\n\treturn\n}",
  "quickstarts_go_ethereum_section3": "func createClient(endpoint string, token string) pb.GraphQLClient {\n\n\tcredential := oauth.NewOauthAccess(&oauth2.Token{AccessToken: token, TokenType: \"Bearer\"})\n\ttransportCreds := credentials.NewClientTLSFromCert(nil, \"\")\n\tconn, err := grpc.Dial(endpoint,\n\t\tgrpc.WithPerRPCCredentials(credential),\n\t\tgrpc.WithTransportCredentials(transportCreds),\n\t)\n\tpanicIfError(err)\n\n\treturn pb.NewGraphQLClient(conn)\n}",
  "quickstarts_go_ethereum_section4": "const operationETH = `subscription {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`\n\ntype ethereumDocument struct {\n\tSearchTransactions struct {\n\t\tCursor string\n\t\tUndo   bool\n\t\tNode   struct {\n\t\t\tHash          string\n\t\t\tMatchingCalls []struct {\n\t\t\t\tFrom  string\n\t\t\t\tTo    string\n\t\t\t\tValue string\n\t\t\t}\n\t\t}\n\t}\n}",
  "quickstarts_go_ethereum_section5": "func streamEthereum(ctx context.Context, client pb.GraphQLClient) {\n\n\texecutor, err := client.Execute(ctx, &pb.Request{Query: operationETH})\n\tpanicIfError(err)\n\n\tfor {\n\t\tresp, err := executor.Recv()\n\t\tpanicIfError(err)\n\n\t\tif len(resp.Errors) > 0 {\n\t\t\tfor _, err := range resp.Errors {\n\t\t\t\tfmt.Printf(\"Request failed: %s\\n\", err)\n\t\t\t}\n\n\t\t\t/* We continue here, but you could take another decision here, like exiting the process */\n\t\t\tcontinue\n\t\t}\n\n\t\tdocument := &ethereumDocument{}\n\t\terr = json.Unmarshal([]byte(resp.Data), document)\n\t\tpanicIfError(err)\n\n\t\tresult := document.SearchTransactions\n\t\treverted := \"\"\n\t\tif result.Undo {\n\t\t\treverted = \" REVERTED\"\n\t\t}\n\n\t\tfor _, call := range result.Node.MatchingCalls {\n\t\t\tfmt.Printf(\"Transfer %s -> %s [%s Ether]%s\\n\", call.From, call.To, call.Value, reverted)\n\t\t}\n\t}\n}",
  "quickstarts_javascript_browser_eos_section1": "<head>\n    <style> li { font-family: monospace; margin: 0.15; }</style>\n    <script src=\"https://unpkg.com/@dfuse/client\"></script>\n    <script>\n        const client = dfuseClient.createDfuseClient({\n          // Replace 'web_abcdef12345678900000000000' with your own API key!\n          apiKey: 'web_abcdef12345678900000000000',\n          network: 'mainnet.eos.dfuse.io'\n        })\n    </script>\n</head>",
  "quickstarts_javascript_browser_eos_section2": "<script>\n// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`\n</script>",
  "quickstarts_javascript_browser_eos_section3": "<script>\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, trace: { id, matchingActions }} = message.data.searchTransactionsForward\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${quantity}]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}\n</script>",
  "quickstarts_javascript_browser_eos_section4": "<script>\nmain().catch((error) => document.body.innerHTML = `<p>${error}</p>`)\n</script>",
  "quickstarts_javascript_bundler_eos_section1": "import { createDfuseClient } from \"@dfuse/client\"\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: \"mainnet.eos.dfuse.io\",\n})",
  "quickstarts_javascript_bundler_eos_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`",
  "quickstarts_javascript_bundler_eos_section3": "// You would normally use your framework entry point and render using components,\n// we are using pure HTML manipulation for sake of example simplicity.\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, trace: { id, matchingActions }} = message.data.searchTransactionsForward\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${quantity}]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}",
  "quickstarts_javascript_bundler_eos_section4": "main().catch((error) => document.body.innerHTML = `<p>${error}</p>`)",
  "quickstarts_javascript_bundler_ethereum_section1": "const { createDfuseClient } = require(\"@dfuse/client\")\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: \"mainnet.eth.dfuse.io\",\n})",
  "quickstarts_javascript_bundler_ethereum_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1, cursor: $cursor) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`",
  "quickstarts_javascript_bundler_ethereum_section3": "// You would normally use your framework entry point and render using components,\n// we are using pure HTML manipulation for sake of example simplicity.\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, node: { hash, value, matchingCalls }} = message.data.searchTransactions\n      matchingCalls.forEach(({ from, to, value }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${value} Ether]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}",
  "quickstarts_javascript_bundler_ethereum_section4": "main().catch((error) => document.body.innerHTML = `<p>${error}</p>`)",
  "quickstarts_javascript_node_eos_section1": "const { createDfuseClient } = require('@dfuse/client');\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: 'mainnet.eos.dfuse.io'\n});",
  "quickstarts_javascript_node_eos_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`;",
  "quickstarts_javascript_node_eos_section3": "async function main() {\n  const stream = await client.graphql(operation, message => {\n    if (message.type === 'data') {\n      const {\n        undo,\n        cursor,\n        trace: { id, matchingActions }\n      } = message.data.searchTransactionsForward;\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        console.log(\n          `Transfer ${from} -> ${to} [${quantity}]${undo ? ' REVERTED' : ''}`\n        );\n      });\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor });\n    }\n\n    if (message.type === 'error') {\n      console.log('An error occurred', message.errors, message.terminal);\n    }\n\n    if (message.type === 'complete') {\n      console.log('Completed');\n    }\n  });\n\n  // Waits until the stream completes, or forever\n  await stream.join();\n  await client.release();\n}",
  "quickstarts_javascript_node_eos_section4": "main().catch(error => console.log('Unexpected error', error));",
  "quickstarts_javascript_node_ethereum_section1": "const { createDfuseClient } = require(\"@dfuse/client\")\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: \"mainnet.eth.dfuse.io\",\n})",
  "quickstarts_javascript_node_ethereum_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1, cursor: $cursor) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`",
  "quickstarts_javascript_node_ethereum_section3": "async function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, node: { hash, value, matchingCalls }} = message.data.searchTransactions\n      matchingCalls.forEach(({ from, to, value }) => {\n        console.log(`Transfer ${from} -> ${to} [${value} Ether]${undo ? \" REVERTED\" : \"\"}`)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      console.log(\"An error occurred\", message.errors, message.terminal)\n    }\n\n    if (message.type === \"complete\") {\n      console.log(\"Completed\")\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}",
  "quickstarts_javascript_node_ethereum_section4": "main().catch((error) => console.log(\"Unexpected error\", error))",
  "quickstarts_python_eos_section1": "try:\n    # python3\n    from http.client import HTTPSConnection\nexcept ImportError:\n    # python2\n    from httplib import HTTPSConnection\n\nimport grpc\nimport json\nimport os\nimport ssl\nimport sys\n\nfrom graphql import graphql_pb2_grpc\nfrom graphql.graphql_pb2 import Request",
  "quickstarts_python_eos_section2": "def get_token(api_key):\n    connection = HTTPSConnection(\"auth.dfuse.io\")\n    connection.request('POST', '/v1/auth/issue', json.dumps({\"api_key\": api_key}), {'Content-type': 'application/json'})\n    response = connection.getresponse()\n\n    if response.status != 200:\n        raise Exception(\" Status: %s reason: %s\" % (response.status, response.reason))\n\n    token = json.loads(response.read().decode())['token']\n    connection.close()\n\n    return token",
  "quickstarts_python_eos_section3": "def create_client(endpoint):\n    dfuse_api_key = os.environ.get(\"DFUSE_API_KEY\")\n    if dfuse_api_key == None:\n        raise Exception(\"you must specify a DFUSE_API_KEY environment variable\")\n\n    channel = grpc.secure_channel(endpoint,\n        credentials = grpc.composite_channel_credentials(\n            grpc.ssl_channel_credentials(),\n            grpc.access_token_call_credentials(get_token(dfuse_api_key))\n    ))\n\n    return graphql_pb2_grpc.GraphQLStub(channel)",
  "quickstarts_python_eos_section4": "OPERATION_EOS = \"\"\"subscription {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer\") {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}\"\"\"",
  "quickstarts_python_eos_section5": "def stream_eosio():\n  \t# The client can be re-used for all requests, cache it at the appropriate level\n    client = create_client('mainnet.eos.dfuse.io:443')\n    stream = client.Execute(Request(query = OPERATION_EOS))\n\n    for rawResult in stream:\n        if rawResult.errors:\n            print(\"An error occurred\")\n            print(rawResult.errors)\n        else:\n            result = json.loads(rawResult.data)\n            for action in result['searchTransactionsForward']['trace']['matchingActions']:\n                undo = result['searchTransactionsForward']['undo']\n                data = action['json']\n                print(\"Transfer %s -> %s [%s]%s\" % (data['from'], data['to'], data['quantity'], \" REVERTED\" if undo else \"\"))",
  "quickstarts_python_eos_section6": "# DFUSE_API_KEY=\"server_abcdef12345678900000000000\" python main.py eosio|ethereum\nproto = \"\"\nif len(sys.argv) > 1:\n    proto = sys.argv[1].lower()\n\nif proto == \"ethereum\" or proto == \"ETH\":\n    stream_ethereum()\nelse:\n    stream_eosio()",
  "quickstarts_python_ethereum_section1": "try:\n    # python3\n    from http.client import HTTPSConnection\nexcept ImportError:\n    # python2\n    from httplib import HTTPSConnection\n\nimport grpc\nimport json\nimport os\nimport ssl\nimport sys\n\nfrom graphql import graphql_pb2_grpc\nfrom graphql.graphql_pb2 import Request",
  "quickstarts_python_ethereum_section2": "def get_token(api_key):\n    connection = HTTPSConnection(\"auth.dfuse.io\")\n    connection.request('POST', '/v1/auth/issue', json.dumps({\"api_key\": api_key}), {'Content-type': 'application/json'})\n    response = connection.getresponse()\n\n    if response.status != 200:\n        raise Exception(\" Status: %s reason: %s\" % (response.status, response.reason))\n\n    token = json.loads(response.read().decode())['token']\n    connection.close()\n\n    return token",
  "quickstarts_python_ethereum_section3": "def create_client(token, endpoint):\n    channel = grpc.secure_channel(endpoint,\n        credentials = grpc.composite_channel_credentials(\n            grpc.ssl_channel_credentials(),\n            grpc.access_token_call_credentials(token)\n    ))\n\n    return graphql_pb2_grpc.GraphQLStub(channel)",
  "quickstarts_python_ethereum_section4": "OPERATION_ETH = \"\"\"subscription {\n  searchTransactions(indexName: CALLS, query: \"-value:0 type:call\", lowBlockNum: -1) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}\"\"\"",
  "quickstarts_python_ethereum_section5": "def stream_ethereum(client):\n    # The client can be re-used for all requests, cache it at the appropriate level\n    stream = client.Execute(Request(query = OPERATION_ETH))\n\n    for rawResult in stream:\n        if rawResult.errors:\n            print(\"An error occurred\")\n            print(rawResult.errors)\n        else:\n            result = json.loads(rawResult.data)\n            for call in result['searchTransactions']['node']['matchingCalls']:\n                undo = result['searchTransactions']['undo']\n                print(\"Transfer %s -> %s [%s Ether]%s\" % (call['from'], call['to'], call['value'], \" REVERTED\" if undo else \"\"))",
  "quickstarts_python_ethereum_section6": "dfuse_api_key = os.environ.get(\"DFUSE_API_KEY\")\nif dfuse_api_key == None or dfuse_api_key == 'your dfuse api key here':\n    raise Exception('you must specify a DFUSE_API_KEY environment variable')\n\ntoken = get_token(dfuse_api_key)\n# The client can be re-used for all requests, cache it at the appropriate level\n\nclient = create_client(token, 'mainnet.eth.dfuse.io:443')\nstream_ethereum(client)",
  "tutorials_eth_stream_css_section1": ".App {\n    text-align: left;\n    width:1080px;\n    margin:auto auto;\n    display: flex;\n    flex-direction: row;\n}\n\n.App .form {\n    padding-top:50px;\n\n    text-align: center;\n}\n\n.App .data {\n    padding:50px;\n    width: 100%;\n}\n\n.App .data pre {\n    padding:10px;\n    white-space: pre-wrap;\n    white-space: -moz-pre-wrap;\n    white-space: -o-pre-wrap;\n    word-wrap: break-word;\n}\n\n\n.trx-id {\n    padding: 18.5px 14px;\n    height: 1.1875em;\n    background: none;\n    box-sizing: content-box;\n    border:thin #878787 solid;\n    width:300px;\n    margin-bottom:10px;\n}\n\n.submit {\n    color: #fff;\n    height: 40px;\n    font-size: 16px;\n    box-shadow: none;\n    line-height: 16px;\n    padding-top: 10px;\n    padding-left: 40px;\n    border-radius: 20px;\n    padding-right: 40px;\n    padding-bottom: 10px;\n    text-transform: none;\n    background-color: #ff4660;\n}\n\n.transition {\n    padding:7px;\n    border-radius: 2px;\n    background: #f8f8fa;\n    border: thin solid #f8f9fa;\n    margin-top: 10px;\n    margin-bottom: 10px;\n\n}\n.error {\n    color: #721c24;\n    background-color: #f8d7da;\n    border-color: #f5c6cb;\n    padding:20px;\n    width: 100%;\n}\n\n.state {\n    color: #fff;\n    background-color: #17a2b8;\n    display: inline-block;\n    padding: .25em .4em;\n    font-size: 75%;\n    font-weight: 700;\n    line-height: 1;\n    text-align: center;\n    white-space: nowrap;\n    vertical-align: baseline;\n    border-radius: .25rem;\n}",
  "tutorials_eth_stream_section1": "import React, { useState } from 'react';\nimport { createDfuseClient } from '@dfuse/client';\nimport './App.css';",
  "tutorials_eth_stream_section2": "  const dfuseClient = createDfuseClient({\n    apiKey,\n    network,\n    streamClientOptions: {\n      socketOptions: {\n        onClose: onClose,\n        onError: onError\n      }\n    }\n  });",
  "tutorials_eth_stream_section3": "  const streamTransfersQuery = `subscription($cursor: String) {\n      searchTransactions(indexName: CALLS, query: \"-value:0\", sort: ASC, limit: 100, cursor: $cursor) {\n        undo cursor\n        node { hash from to value(encoding: ETHER) }\n      }\n    }`;",
  "tutorials_eth_stream_section4": "  const [transfers, setTransfers] = useState([]);\n  const [state, setState] = useState('initialize');\n  const [errors, setErrors] = useState([]);\n  const [stream, setStream] = useState(undefined);",
  "tutorials_eth_stream_section5": "  const streamTransfers = async () => {\n    setTransfers([]);\n    setErrors([]);\n    setState('connected');\n    setErrors('');\n    let currentTransfers = [];\n    try {\n      const stream = await dfuseClient.graphql(\n        streamTransfersQuery,\n        async message => {\n          if (message.type === 'error') {\n            setErrors([\n              'An error occurred',\n              ...message.errors.map(error => error.message),\n              ...errors\n            ]);\n          }\n\n          if (message.type === 'data') {\n            const {\n              node: newTransfer,\n              cursor\n            } = message.data.searchTransactions;\n\n            currentTransfers = [newTransfer, ...currentTransfers];\n            setTransfers(currentTransfers);\n            stream.mark({ cursor });\n          }\n\n          if (message.type === 'complete') {\n            setState('completed');\n          }\n        }\n      );\n      setStream(stream);\n    } catch (errors) {\n      setErrors(JSON.stringify(errors));\n      setState('completed');\n    }\n  };",
  "tutorials_eth_stream_section6": "  const onStop = async () => {\n    setState('completed');\n    if (stream === undefined) {\n      return;\n    }\n    try {\n      await stream.close();\n      setStream(undefined);\n    } catch (error) {\n      setErrors(\n        `Unable to disconnect socket correctly: \n          ${JSON.stringify(error)}\n        `\n      );\n    }\n  };\n\n  const onClose = () => {\n    setState('completed');\n  };\n\n  const onError = error => {\n    setErrors(\n      `Unable to disconnect socket correctly: \n      ${JSON.stringify(error)}\n    `\n    );\n  };",
  "tutorials_eth_stream_section7": "  const renderTransfer = (transfer, index) => {\n    const { hash, from, to, value } = transfer;\n    return hash ? (\n      <code key={index} className='App-transfer'>\n        Transfer\n        <br />\n        {`From: ${from} -> To: ${to}`}\n        <br />\n        {`Value: ${value} Hash: ${hash}`}\n        <hr />\n      </code>\n    ) : (\n      <code key={index} className='App-transfer'>\n        {transfer}\n      </code>\n    );\n  };\n\n  const renderTransfers = () => {\n    return (\n      <div className='App-infinite-container'>\n        {transfers.length <= 0\n          ? renderTransfer('Nothing yet, start by hitting Launch!')\n          : transfers.reverse().map(renderTransfer)}\n      </div>\n    );\n  };\n\n  const renderError = (error, index) => {\n    if (error === '') {\n      return <br key={index} className='App-error' />;\n    }\n\n    return (\n      <code key={index} className='App-error'>\n        {error}\n      </code>\n    );\n  };\n\n  const renderErrors = () => {\n    if (errors.length <= 0) {\n      return null;\n    }\n\n    return <div className='App-container'>{errors.map(renderError)}</div>;\n  };\n\n  return (\n    <div className='App'>\n      <header className='App-header'>\n        <h2>Stream Ethereum Transfers</h2>\n        {renderErrors()}\n        <div className='App-buttons'>\n          <button className='App-button' onClick={streamTransfers}>\n            Launch\n          </button>\n          <button className='App-button' onClick={onStop}>\n            Stop\n          </button>\n        </div>\n        <main className='App-main'>\n          <p className='App-status'>\n            {`Connected: ${\n              state === 'connected'\n                ? 'Connected (Showing last 100 transfers)'\n                : 'Disconnected'\n            }`}\n          </p>\n          {renderTransfers()}\n        </main>\n      </header>\n    </div>\n  );\n}",
  "tutorials_eth_stream_section8": "import React, { useState } from 'react';\nimport { createDfuseClient } from '@dfuse/client';\nimport './App.css';\nconst apiKey = process.env.REACT_APP_DFUSE_API_KEY;\nconst network = process.env.REACT_APP_DFUSE_NETWORK || 'mainnet.eth.dfuse.io';\n\nfunction App() {  const dfuseClient = createDfuseClient({\n    apiKey,\n    network,\n    streamClientOptions: {\n      socketOptions: {\n        onClose: onClose,\n        onError: onError\n      }\n    }\n  });  const streamTransfersQuery = `subscription($cursor: String) {\n      searchTransactions(indexName: CALLS, query: \"-value:0\", sort: ASC, limit: 100, cursor: $cursor) {\n        undo cursor\n        node { hash from to value(encoding: ETHER) }\n      }\n    }`;  const [transfers, setTransfers] = useState([]);\n  const [state, setState] = useState('initialize');\n  const [errors, setErrors] = useState([]);\n  const [stream, setStream] = useState(undefined);  const streamTransfers = async () => {\n    setTransfers([]);\n    setErrors([]);\n    setState('connected');\n    setErrors('');\n    let currentTransfers = [];\n    try {\n      const stream = await dfuseClient.graphql(\n        streamTransfersQuery,\n        async message => {\n          if (message.type === 'error') {\n            setErrors([\n              'An error occurred',\n              ...message.errors.map(error => error.message),\n              ...errors\n            ]);\n          }\n\n          if (message.type === 'data') {\n            const {\n              node: newTransfer,\n              cursor\n            } = message.data.searchTransactions;\n\n            currentTransfers = [newTransfer, ...currentTransfers];\n            setTransfers(currentTransfers);\n            stream.mark({ cursor });\n          }\n\n          if (message.type === 'complete') {\n            setState('completed');\n          }\n        }\n      );\n      setStream(stream);\n    } catch (errors) {\n      setErrors(JSON.stringify(errors));\n      setState('completed');\n    }\n  };  const onStop = async () => {\n    setState('completed');\n    if (stream === undefined) {\n      return;\n    }\n    try {\n      await stream.close();\n      setStream(undefined);\n    } catch (error) {\n      setErrors(\n        `Unable to disconnect socket correctly: \n          ${JSON.stringify(error)}\n        `\n      );\n    }\n  };\n\n  const onClose = () => {\n    setState('completed');\n  };\n\n  const onError = error => {\n    setErrors(\n      `Unable to disconnect socket correctly: \n      ${JSON.stringify(error)}\n    `\n    );\n  };  const renderTransfer = (transfer, index) => {\n    const { hash, from, to, value } = transfer;\n    return hash ? (\n      <code key={index} className='App-transfer'>\n        Transfer\n        <br />\n        {`From: ${from} -> To: ${to}`}\n        <br />\n        {`Value: ${value} Hash: ${hash}`}\n        <hr />\n      </code>\n    ) : (\n      <code key={index} className='App-transfer'>\n        {transfer}\n      </code>\n    );\n  };\n\n  const renderTransfers = () => {\n    return (\n      <div className='App-infinite-container'>\n        {transfers.length <= 0\n          ? renderTransfer('Nothing yet, start by hitting Launch!')\n          : transfers.reverse().map(renderTransfer)}\n      </div>\n    );\n  };\n\n  const renderError = (error, index) => {\n    if (error === '') {\n      return <br key={index} className='App-error' />;\n    }\n\n    return (\n      <code key={index} className='App-error'>\n        {error}\n      </code>\n    );\n  };\n\n  const renderErrors = () => {\n    if (errors.length <= 0) {\n      return null;\n    }\n\n    return <div className='App-container'>{errors.map(renderError)}</div>;\n  };\n\n  return (\n    <div className='App'>\n      <header className='App-header'>\n        <h2>Stream Ethereum Transfers</h2>\n        {renderErrors()}\n        <div className='App-buttons'>\n          <button className='App-button' onClick={streamTransfers}>\n            Launch\n          </button>\n          <button className='App-button' onClick={onStop}>\n            Stop\n          </button>\n        </div>\n        <main className='App-main'>\n          <p className='App-status'>\n            {`Connected: ${\n              state === 'connected'\n                ? 'Connected (Showing last 100 transfers)'\n                : 'Disconnected'\n            }`}\n          </p>\n          {renderTransfers()}\n        </main>\n      </header>\n    </div>\n  );\n}\nexport default App;"
}