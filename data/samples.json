{
  "quickstarts_go_ethereum_section1": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\tpb \"go/graphql\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/tidwall/gjson\"\n\t\"golang.org/x/oauth2\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/oauth\"\n)\n\nfunc main() {\n\n\tdfuseAPIKey := os.Getenv(\"DFUSE_API_KEY\")\n\tif dfuseAPIKey == \"\" || dfuseAPIKey == \"your dfuse api key here\" {\n\t\tpanic(\"you must specify a DFUSE_API_KEY environment variable\")\n\t}\n\n\ttoken, _, err := getToken(dfuseAPIKey)\n\tpanicIfError(err)\n\n\tclient := createClient(\"mainnet.eth.dfuse.io:443\", token)\n\n\tstreamEthereum(context.Background(), client)\n}\n\nfunc panicIfError(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}",
  "quickstarts_go_ethereum_section2": "func getToken(apiKey string) (token string, expiration time.Time, err error) {\n\treqBody := bytes.NewBuffer([]byte(fmt.Sprintf(`{\"api_key\":\"%s\"}`, apiKey)))\n\tresp, err := http.Post(\"https://auth.dfuse.io/v1/auth/issue\", \"application/json\", reqBody)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to obtain token: %s\", err)\n\t\treturn\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\terr = fmt.Errorf(\"unable to obtain token, status not 200, got %d: %s\", resp.StatusCode, reqBody.String())\n\t\treturn\n\t}\n\n\tif body, err := ioutil.ReadAll(resp.Body); err == nil {\n\t\ttoken = gjson.GetBytes(body, \"token\").String()\n\t\texpiration = time.Unix(gjson.GetBytes(body, \"expires_at\").Int(), 0)\n\t}\n\treturn\n}",
  "quickstarts_go_ethereum_section3": "func createClient(endpoint string, token string) pb.GraphQLClient {\n\n\tcredential := oauth.NewOauthAccess(&oauth2.Token{AccessToken: token, TokenType: \"Bearer\"})\n\ttransportCreds := credentials.NewClientTLSFromCert(nil, \"\")\n\tconn, err := grpc.Dial(endpoint,\n\t\tgrpc.WithPerRPCCredentials(credential),\n\t\tgrpc.WithTransportCredentials(transportCreds),\n\t)\n\tpanicIfError(err)\n\n\treturn pb.NewGraphQLClient(conn)\n}",
  "quickstarts_go_ethereum_section4": "const operationETH = `subscription {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`\n\ntype ethereumDocument struct {\n\tSearchTransactions struct {\n\t\tCursor string\n\t\tUndo   bool\n\t\tNode   struct {\n\t\t\tHash          string\n\t\t\tMatchingCalls []struct {\n\t\t\t\tFrom  string\n\t\t\t\tTo    string\n\t\t\t\tValue string\n\t\t\t}\n\t\t}\n\t}\n}",
  "quickstarts_go_ethereum_section5": "func streamEthereum(ctx context.Context, client pb.GraphQLClient) {\n\n\texecutor, err := client.Execute(ctx, &pb.Request{Query: operationETH})\n\tpanicIfError(err)\n\n\tfor {\n\t\tresp, err := executor.Recv()\n\t\tpanicIfError(err)\n\n\t\tif len(resp.Errors) > 0 {\n\t\t\tfor _, err := range resp.Errors {\n\t\t\t\tfmt.Printf(\"Request failed: %s\\n\", err)\n\t\t\t}\n\n\t\t\t/* We continue here, but you could take another decision here, like exiting the process */\n\t\t\tcontinue\n\t\t}\n\n\t\tdocument := &ethereumDocument{}\n\t\terr = json.Unmarshal([]byte(resp.Data), document)\n\t\tpanicIfError(err)\n\n\t\tresult := document.SearchTransactions\n\t\treverted := \"\"\n\t\tif result.Undo {\n\t\t\treverted = \" REVERTED\"\n\t\t}\n\n\t\tfor _, call := range result.Node.MatchingCalls {\n\t\t\tfmt.Printf(\"Transfer %s -> %s [%s Ether]%s\\n\", call.From, call.To, call.Value, reverted)\n\t\t}\n\t}\n}",
  "quickstarts_javascript_browser_eos_section1": "<head>\n    <style> li { font-family: monospace; margin: 0.15; }</style>\n    <script src=\"https://unpkg.com/@dfuse/client\"></script>\n    <script>\n        const client = dfuseClient.createDfuseClient({\n          // Replace 'web_abcdef12345678900000000000' with your own API key!\n          apiKey: 'web_abcdef12345678900000000000',\n          network: 'mainnet.eos.dfuse.io'\n        })\n    </script>\n</head>",
  "quickstarts_javascript_browser_eos_section2": "<script>\n// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`\n</script>",
  "quickstarts_javascript_browser_eos_section3": "<script>\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, trace: { id, matchingActions }} = message.data.searchTransactionsForward\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${quantity}]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}\n</script>",
  "quickstarts_javascript_browser_eos_section4": "<script>\nmain().catch((error) => document.body.innerHTML = `<p>${error}</p>`)\n</script>",
  "quickstarts_javascript_bundler_ethereum_section1": "const { createDfuseClient } = require(\"@dfuse/client\")\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: \"mainnet.eth.dfuse.io\",\n})",
  "quickstarts_javascript_bundler_ethereum_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1, cursor: $cursor) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`",
  "quickstarts_javascript_bundler_ethereum_section3": "// You would normally use your framework entry point and render using components,\n// we are using pure HTML manipulation for sake of example simplicity.\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, node: { hash, value, matchingCalls }} = message.data.searchTransactions\n      matchingCalls.forEach(({ from, to, value }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${value} Ether]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}",
  "quickstarts_javascript_bundler_ethereum_section4": "main().catch((error) => document.body.innerHTML = `<p>${error}</p>`)",
  "quickstarts_javascript_bundler_eos_section1": "import { createDfuseClient } from \"@dfuse/client\"\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: \"mainnet.eos.dfuse.io\",\n})",
  "quickstarts_javascript_bundler_eos_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`",
  "quickstarts_javascript_bundler_eos_section3": "// You would normally use your framework entry point and render using components,\n// we are using pure HTML manipulation for sake of example simplicity.\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, trace: { id, matchingActions }} = message.data.searchTransactionsForward\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${quantity}]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}",
  "quickstarts_javascript_bundler_eos_section4": "main().catch((error) => document.body.innerHTML = `<p>${error}</p>`)",
  "quickstarts_javascript_node_ethereum_section1": "const { createDfuseClient } = require(\"@dfuse/client\")\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: \"mainnet.eth.dfuse.io\",\n})",
  "quickstarts_javascript_node_ethereum_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1, cursor: $cursor) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`",
  "quickstarts_javascript_node_ethereum_section3": "async function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, node: { hash, value, matchingCalls }} = message.data.searchTransactions\n      matchingCalls.forEach(({ from, to, value }) => {\n        console.log(`Transfer ${from} -> ${to} [${value} Ether]${undo ? \" REVERTED\" : \"\"}`)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      console.log(\"An error occurred\", message.errors, message.terminal)\n    }\n\n    if (message.type === \"complete\") {\n      console.log(\"Completed\")\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}",
  "quickstarts_javascript_node_ethereum_section4": "main().catch((error) => console.log(\"Unexpected error\", error))",
  "quickstarts_go_eos_section1": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\tpb \"github.com/dfuse-io/docs/quickstarts/pb\"\n\t\"github.com/tidwall/gjson\"\n\t\"golang.org/x/oauth2\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/oauth\"\n)",
  "quickstarts_go_eos_section2": "func getToken(apiKey string) (token string, expiration time.Time, err error) {\n\treqBody := bytes.NewBuffer([]byte(fmt.Sprintf(`{\"api_key\":\"%s\"}`, apiKey)))\n\tresp, err := http.Post(\"https://auth.dfuse.io/v1/auth/issue\", \"application/json\", reqBody)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to obtain token: %s\", err)\n\t\treturn\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\terr = fmt.Errorf(\"unable to obtain token, status not 200, got %d: %s\", resp.StatusCode, reqBody.String())\n\t\treturn\n\t}\n\n\tif body, err := ioutil.ReadAll(resp.Body); err == nil {\n\t\ttoken = gjson.GetBytes(body, \"token\").String()\n\t\texpiration = time.Unix(gjson.GetBytes(body, \"expires_at\").Int(), 0)\n\t}\n\treturn\n}",
  "quickstarts_go_eos_section3": "func createClient(endpoint string) pb.GraphQLClient {\n\tdfuseAPIKey := os.Getenv(\"DFUSE_API_KEY\")\n\tif dfuseAPIKey == \"\" {\n\t\tpanic(\"you must specify a DFUSE_API_KEY environment variable\")\n\t}\n\n\ttoken, _, err := getToken(dfuseAPIKey)\n\tpanicIfError(err)\n\n\tcredential := oauth.NewOauthAccess(&oauth2.Token{AccessToken: token, TokenType: \"Bearer\"})\n\ttransportCreds := credentials.NewClientTLSFromCert(nil, \"\")\n\tconn, err := grpc.Dial(endpoint,\n\t\tgrpc.WithPerRPCCredentials(credential),\n\t\tgrpc.WithTransportCredentials(transportCreds),\n\t)\n\tpanicIfError(err)\n\n\treturn pb.NewGraphQLClient(conn)\n}",
  "quickstarts_go_eos_section4": "const operationEOS = `subscription {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\") {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`\n\ntype eosioDocument struct {\n\tSearchTransactionsForward struct {\n\t\tCursor string\n\t\tUndo   bool\n\t\tTrace  struct {\n\t\t\tID              string\n\t\t\tMatchingActions []struct {\n\t\t\t\tJSON map[string]interface{}\n\t\t\t}\n\t\t}\n\t}\n}",
  "quickstarts_go_eos_section5": "func streamEOSIO(ctx context.Context) {\n\t/* The client can be re-used for all requests, cache it at the appropriate level */\n\tclient := createClient(\"mainnet.eos.dfuse.io:443\")\n\texecutor, err := client.Execute(ctx, &pb.Request{Query: operationEOS})\n\tpanicIfError(err)\n\n\tfor {\n\t\tresp, err := executor.Recv()\n\t\tpanicIfError(err)\n\n\t\tif len(resp.Errors) > 0 {\n\t\t\tfor _, err := range resp.Errors {\n\t\t\t\tfmt.Printf(\"Request failed: %s\\n\", err)\n\t\t\t}\n\n\t\t\t/* We continue here, but you could take another decision here, like exiting the process */\n\t\t\tcontinue\n\t\t}\n\n\t\tdocument := &eosioDocument{}\n\t\terr = json.Unmarshal([]byte(resp.Data), document)\n\t\tpanicIfError(err)\n\n\t\tresult := document.SearchTransactionsForward\n\t\treverted := \"\"\n\t\tif result.Undo {\n\t\t\treverted = \" REVERTED\"\n\t\t}\n\n\t\tfor _, action := range result.Trace.MatchingActions {\n\t\t\tdata := action.JSON\n\t\t\tfmt.Printf(\"Transfer %s -> %s [%s]%s\\n\", data[\"from\"], data[\"to\"], data[\"quantity\"], reverted)\n\t\t}\n\t}\n}",
  "quickstarts_go_eos_section6": "func main() {\n\tproto := \"\"\n\tif len(os.Args) >= 2 {\n\t\tproto = os.Args[1]\n\t}\n\n\tswitch proto {\n\tcase \"ethereum\", \"ETH\":\n\t\tstreamEthereum(context.Background())\n\tdefault:\n\t\tstreamEOSIO(context.Background())\n\t}\n}\n\nfunc panicIfError(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}",
  "quickstarts_javascript_node_eos_section1": "const { createDfuseClient } = require('@dfuse/client');\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: 'mainnet.eos.dfuse.io'\n});",
  "quickstarts_javascript_node_eos_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`;",
  "quickstarts_javascript_node_eos_section3": "async function main() {\n  const stream = await client.graphql(operation, message => {\n    if (message.type === 'data') {\n      const {\n        undo,\n        cursor,\n        trace: { id, matchingActions }\n      } = message.data.searchTransactionsForward;\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        console.log(\n          `Transfer ${from} -> ${to} [${quantity}]${undo ? ' REVERTED' : ''}`\n        );\n      });\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor });\n    }\n\n    if (message.type === 'error') {\n      console.log('An error occurred', message.errors, message.terminal);\n    }\n\n    if (message.type === 'complete') {\n      console.log('Completed');\n    }\n  });\n\n  // Waits until the stream completes, or forever\n  await stream.join();\n  await client.release();\n}",
  "quickstarts_javascript_node_eos_section4": "main().catch(error => console.log('Unexpected error', error));",
  "quickstarts_javascript_browser_ethereum_section1": "<head>\n    <style> li { font-family: monospace; margin: 0.15; }</style>\n    <script src=\"https://unpkg.com/@dfuse/client\"></script>\n    <script>\n        const client = dfuseClient.createDfuseClient({\n          // Replace 'web_abcdef12345678900000000000' with your own API key!\n          apiKey: 'web_abcdef12345678900000000000',\n          network: 'mainnet.eth.dfuse.io'\n        })\n    </script>\n</head>",
  "quickstarts_javascript_browser_ethereum_section2": "<script>\n// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1, cursor: $cursor) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`\n</script>",
  "quickstarts_javascript_browser_ethereum_section3": "<script>\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, node: { hash, value, matchingCalls }} = message.data.searchTransactions\n      matchingCalls.forEach(({ from, to, value }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${value} Ether]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}\n</script>",
  "quickstarts_javascript_browser_ethereum_section4": "<script>\nmain().catch((error) => document.body.innerHTML = `<p>${error}</p>`)\n</script>",
  "quickstarts_python_ethereum_section1": "try:\n    # python3\n    from http.client import HTTPSConnection\nexcept ImportError:\n    # python2\n    from httplib import HTTPSConnection\n\nimport grpc\nimport json\nimport os\nimport ssl\nimport sys\n\nfrom graphql import graphql_pb2_grpc\nfrom graphql.graphql_pb2 import Request",
  "quickstarts_python_ethereum_section2": "def get_token(api_key):\n    connection = HTTPSConnection(\"auth.dfuse.io\")\n    connection.request('POST', '/v1/auth/issue', json.dumps({\"api_key\": api_key}), {'Content-type': 'application/json'})\n    response = connection.getresponse()\n\n    if response.status != 200:\n        raise Exception(\" Status: %s reason: %s\" % (response.status, response.reason))\n\n    token = json.loads(response.read().decode())['token']\n    connection.close()\n\n    return token",
  "quickstarts_python_ethereum_section3": "def create_client(token, endpoint):\n    channel = grpc.secure_channel(endpoint,\n        credentials = grpc.composite_channel_credentials(\n            grpc.ssl_channel_credentials(),\n            grpc.access_token_call_credentials(token)\n    ))\n\n    return graphql_pb2_grpc.GraphQLStub(channel)",
  "quickstarts_python_ethereum_section4": "OPERATION_ETH = \"\"\"subscription {\n  searchTransactions(indexName: CALLS, query: \"-value:0 type:call\", lowBlockNum: -1) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}\"\"\"",
  "quickstarts_python_ethereum_section5": "def stream_ethereum(client):\n    # The client can be re-used for all requests, cache it at the appropriate level\n    stream = client.Execute(Request(query = OPERATION_ETH))\n\n    for rawResult in stream:\n        if rawResult.errors:\n            print(\"An error occurred\")\n            print(rawResult.errors)\n        else:\n            result = json.loads(rawResult.data)\n            for call in result['searchTransactions']['node']['matchingCalls']:\n                undo = result['searchTransactions']['undo']\n                print(\"Transfer %s -> %s [%s Ether]%s\" % (call['from'], call['to'], call['value'], \" REVERTED\" if undo else \"\"))",
  "quickstarts_python_ethereum_section6": "dfuse_api_key = os.environ.get(\"DFUSE_API_KEY\")\nif dfuse_api_key == None or dfuse_api_key == 'your dfuse api key here':\n    raise Exception('you must specify a DFUSE_API_KEY environment variable')\n\ntoken = get_token(dfuse_api_key)\n# The client can be re-used for all requests, cache it at the appropriate level\n\nclient = create_client(token, 'mainnet.eth.dfuse.io:443')\nstream_ethereum(client)",
  "quickstarts_python_eos_section1": "try:\n    # python3\n    from http.client import HTTPSConnection\nexcept ImportError:\n    # python2\n    from httplib import HTTPSConnection\n\nimport grpc\nimport json\nimport os\nimport ssl\nimport sys\n\nfrom graphql import graphql_pb2_grpc\nfrom graphql.graphql_pb2 import Request",
  "quickstarts_python_eos_section2": "def get_token(api_key):\n    connection = HTTPSConnection(\"auth.dfuse.io\")\n    connection.request('POST', '/v1/auth/issue', json.dumps({\"api_key\": api_key}), {'Content-type': 'application/json'})\n    response = connection.getresponse()\n\n    if response.status != 200:\n        raise Exception(\" Status: %s reason: %s\" % (response.status, response.reason))\n\n    token = json.loads(response.read().decode())['token']\n    connection.close()\n\n    return token",
  "quickstarts_python_eos_section3": "def create_client(endpoint):\n    dfuse_api_key = os.environ.get(\"DFUSE_API_KEY\")\n    if dfuse_api_key == None:\n        raise Exception(\"you must specify a DFUSE_API_KEY environment variable\")\n\n    channel = grpc.secure_channel(endpoint,\n        credentials = grpc.composite_channel_credentials(\n            grpc.ssl_channel_credentials(),\n            grpc.access_token_call_credentials(get_token(dfuse_api_key))\n    ))\n\n    return graphql_pb2_grpc.GraphQLStub(channel)",
  "quickstarts_python_eos_section4": "OPERATION_EOS = \"\"\"subscription {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer\") {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}\"\"\"",
  "quickstarts_python_eos_section5": "def stream_eosio():\n  \t# The client can be re-used for all requests, cache it at the appropriate level\n    client = create_client('mainnet.eos.dfuse.io:443')\n    stream = client.Execute(Request(query = OPERATION_EOS))\n\n    for rawResult in stream:\n        if rawResult.errors:\n            print(\"An error occurred\")\n            print(rawResult.errors)\n        else:\n            result = json.loads(rawResult.data)\n            for action in result['searchTransactionsForward']['trace']['matchingActions']:\n                undo = result['searchTransactionsForward']['undo']\n                data = action['json']\n                print(\"Transfer %s -> %s [%s]%s\" % (data['from'], data['to'], data['quantity'], \" REVERTED\" if undo else \"\"))",
  "quickstarts_python_eos_section6": "# DFUSE_API_KEY=\"server_abcdef12345678900000000000\" python main.py eosio|ethereum\nproto = \"\"\nif len(sys.argv) > 1:\n    proto = sys.argv[1].lower()\n\nif proto == \"ethereum\" or proto == \"ETH\":\n    stream_ethereum()\nelse:\n    stream_eosio()"
}